<!-- Converted by db4-upgrade version 1.0 -->
<book xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="index" xmlns:xlink="http://www.w3.org/1999/xlink" xml:lang="en-GB">
    <info><title>Freecell Solver - Architecture Document</title>


        <authorgroup>
            <author><personname><firstname>Shlomi</firstname><surname>Fish</surname></personname><affiliation>
                    <address>
                        <email>shlomif@shlomifish.org</email>
                        <uri type="homepage" xlink:href="http://www.shlomifish.org/">Shlomi Fish’s Homepage</uri>
                    </address>
                </affiliation></author>
        </authorgroup>
        <releaseinfo>This is version 0.5.0</releaseinfo>

        <copyright>
            <year>2002</year>
            <holder>Shlomi Fish</holder>
        </copyright>

        <legalnotice>
            <!-- Ci vis pacem -->
            <para>
                <!-- belum. ;-) -->
                This work is licensed under the
                <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://creativecommons.org/licenses/by/3.0/">Creative
                    Commons Attribution 3.0 Unported License</link> (or at
                your option a greater version of it). Whatever source code
                is provided here is licensed under the <link xlink:href="https://en.wikipedia.org/wiki/MIT_License">Expat variant of the MIT License</link>.
            </para>
            <para>
                It was written by
                <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.shlomifish.org/">Shlomi Fish</link>,
                and one should attribute a derived work to him, while linking
                to his homepage. Please see <link xlink:href="http://www.shlomifish.org/meta/copyrights/">my interpretation of the licenses</link>.
            </para>
        </legalnotice>
        <revhistory>
            <revision>
                <revnumber>1.6</revnumber>
                <date>2002-12-02</date>
                <authorinitials>shlomif</authorinitials>
                <revremark>
                    First "stable" version covering the Freecell Solver 2.8.x
                    architecture. Spell checked and revised during its
                    CVS history.
                </revremark>
            </revision>
            <revision>
                <revnumber>835</revnumber>
                <date>2008-07-11</date>
                <authorinitials>shlomif</authorinitials>
                <revremark>
                    Combined everything into one big .xml file instead of
                    the "SYSTEM" entities. Removed the places where
                    vipe.technion.ac.il was mentioned.
                </revremark>
            </revision>
            <revision>
                <revnumber>2081</revnumber>
                <date>2009-06-29</date>
                <authorinitials>shlomif</authorinitials>
                <revremark>
                    Updated to version 2.32.x of Freecell Solver. It's possible
                    some newer techniques are not covered by this document
                    yet, but I hope to remedy it soon.
                </revremark>
            </revision>
            <revision>
                <revnumber>2082</revnumber>
                <date>2018-08-23</date>
                <authorinitials>shlomif</authorinitials>
                <revremark>
                    Converted to DocBook 5.
                </revremark>
            </revision>

        </revhistory>
    </info>

    <chapter xml:id="introduction"><info><title>Introduction</title></info>

        <para>
            This is the architecture document of Freecell Solver. Its purpose is to
            serve as an introduction to the code, so future contributors can
            understand it and work on it.
        </para>
        <para>
            This document does not aim to cover every detail of the
            application. Such details are supposed to be documented within
            the comments of the code. (let me know if there is something
            there you don't understand, and I'll add a comment) Instead,
            it should provide an overview of the code and cover the main
            caveats one would encounter when trying to understand it.
        </para>
        <para>
            This document covers the Freecell Solver 2.8.x architecture, and
            will be updated to future versions.
        </para>
    </chapter>
    <chapter xml:id="coding_conventions"><info><title>Coding Conventions</title></info>

        <section xml:id="bottom_up_design_and_evolution"><info><title>Bottom-Up Design and Evolution</title></info>

            <para>
                Freecell Solver was designed bottom-up: first by writing
                functions to input cards and then to handle states and finally
                the algorithm itself. I find that bottom-up design (as
                <link xlink:href="http://www.paulgraham.com/onlisp.html">evangelised
                    by Paul Graham and others</link>) - start by writing small
                utility functions and classes and then integrate into a grander
                scheme, has been a guiding principle when working on Freecell
                Solver.

            </para>
            <para>
                Freecell Solver has many utility classes, and has also been coded
                incrementally. I also find bottom-up design more natural.
            </para>
        </section>
        <section xml:id="gnu11_c"><info><title>Using the gnu11 C dialect and POSIX</title></info>

            <para>
                Freecell Solver is written using the <code>-std=gnu11</code>
                C dialect and can be compiled using GCC and compatible
                compilers.
            </para>
        </section>
        <section xml:id="strict_adherence_to_the_ansi_c_standard_lib"><info><title>Strict Adherence to the ANSI C Standard Library</title></info>

            <para>
                Freecell Solver is dependant on the ANSI C and
                POSIX Standard Library as defined
                by the standard and on that library alone. The core FCS code is
                not dependant on glib, apr or any other abstraction or
                encapsulation libraries of this kind.
            </para>
            <para>
                Freecell Solver can optionally be compiled to make use of some binary
                trees and hash implementations found in external libraries.
                This serves as a drop-in replacement for its internal hash
                implementation, which was shown to usually give a better
                performance.
            </para>
            <para>
                Note that a lot of the logic provided by such libraries is
                implemented internally in Freecell Solver.
            </para>
        </section>
        <section xml:id="cc_namespace_purity"><info><title>Namespace Purity</title></info>

            <para>
                All the global symbols of the Freecell Solver modules are prefixed with
                <symbol>fc_solve_</symbol> prefix. (See
                <link xlink:href="http://tech.groups.yahoo.com/group/fc-solve-discuss/message/842">this
                    post to the fc-solve-discuss mailing list</link> about why
                we converted away from <symbol>freecell_solver_</symbol>.
                Some macros supplied to the user are prefixed with the
                <symbol>fcs_</symbol> prefix for convenience. The API
                functions in turn are prefixed with
                <symbol>freecell_solver_user_</symbol>, in order to not
                break compatibility with older versions of the library.
            </para>
        </section>
        <section xml:id="cc_order_of_tradeoffs"><info><title>Order of Trade-offs in the Design of the Code</title></info>

            <para>
                Freecell Solver has the following trade offs in the design of the code:
            </para>
            <para>
                <orderedlist inheritnum="ignore" continuation="restarts">
                    <listitem>

                        <para>

                            Modularity - the code should be as generic as
                            possible and allow for maximal flexibility. The
                            user should be able to configure the library as he
                            pleases.

                        </para>
                    </listitem>
                    <listitem>
                        <para>

                            Speed - the code should be optimised for speed.
                            Many times in the code, it was made a bit less
                            comprehensible to gain speed, and many times extra
                            techniques are implemented to ensure this goal.

                        </para>
                    </listitem>
                    <listitem>
                        <para>

                            Memory Consumption - should be reduced as much as
                            possible. A reduced memory consumption usually
                            leads to better speed, because there are less cache
                            misses this way.

                        </para>
                    </listitem>
                    <listitem>

                        <para>

                            Smart Algorithms - generally, algorithms with a low
                            complexity and such that give advantage to the code
                            are implemented.

                        </para>

                    </listitem>
                </orderedlist>
            </para>

            <para>
                Note that these trade-offs are subject to the programmer's
                whims, and many times, one was a bit sacrificed to satisfy
                the other.
            </para>
        </section>
        <section xml:id="cc_no_global_symbols"><info><title>No Global or Static Variables</title></info>

            <para>

                Freecell Solver does not use global variables (except for constants) or
                such that are statically defined within a function. All the
                non-temporary variables are present within structs, so they can
                easily be instantiated.

            </para>
            <para>
                One should note that several distinct instances of the solving
                algorithm can be instantiated and made to run side by side or
                alternately.
            </para>
        </section>
        <section xml:id="cc_separation_of_internals_from_user_interface"><info><title>Separation of Internals from User and Application
                Programmer Interfaces</title></info>

            <para>

                FCS makes a clear distinction between the internals of the
                program, that are subject to change from version to version,
                and between the interface supplied to the user or the
                application programmer. All the modules starting from
                <filename>instance.c</filename> and below are the internals of
                the program.

            </para>
            <para>

                <filename>lib.c</filename> contains the API functions used by
                the programmer. <filename>cmd_line.c</filename> is an API to
                analyse a Freecell Solver command line. It itself uses only the
                <filename>lib.c</filename> API. It provides a more flexible
                interface for configuring Freecell Solver, even to the application
                programmer.

            </para>
            <para>
                <filename>main.c</filename> ,
                <filename>test_multi_parallel.c</filename> ,
                <filename>threaded_range_solver.c</filename> ,
                and <filename>fc_pro_range_solver.c </filename>
                are command line programs that use the command line interface
                and programmers interface. Others can be written (and have
                been written).
            </para>
        </section>
    </chapter>
    <chapter xml:id="code_overview"><info><title>Overview of the Code</title></info>

        <section xml:id="overview_of_the_program"><info><title>Overview of the Program</title></info>


            <para>
                Freecell Solver solves boards by using <link xlink:href="https://en.wikipedia.org/wiki/Depth-first_search">Depth-First Search</link> or
                <link xlink:href="https://en.wikipedia.org/wiki/Best-first_search">Best-First-Search</link> scans starting from the initial board. It
                has a collection of the states, and constructs a tree of the
                states descending from each state to its "parent". A parent
                state means the state in which from which it was discovered.
            </para>

            <para>

                Freecell Solver can run several "move functions" on each state. Each move
                generates a list of derived states. Some of the tests are
                Freecell meta-move ones, some are Freecell atomic move ones,
                and the others are Simple Simon meta-move ones. The order of
                the tests can be specified at the command line, and tests can
                be grouped, and the order of checking of the tests within a
                group will be determined by a special callback.

            </para>
            <para>

                To perform the scans themselves Freecell Solver distinguishes
                between soft threads, hard threads and instances. An instance
                is a collection of states and an initial board to explore. Each
                instance may have several hard threads and each hard thread may
                have several soft threads. A hard thread is something that
                would likely be put in a system thread. It contains such
                resources, that a collision between them among several hard
                threads running in parallel is undesirable. Nevertheless, every
                hard thread can access the resources allocated by other hard
                threads, should it encounter them in its scan.

            </para>
            <para>

                A soft thread is a singular scan. It performs a scan for a
                certain number of iterations, at which point the hard thread
                switches to a different soft thread.

            </para>
        </section>
        <section xml:id="overview_of_the_utility_modules"><info><title>Overview of the Utility Modules</title></info>

            <section xml:id="app_str.c"><info><title>app_str.c</title></info>

                <para>
                    This file contains a utility class that appends sprintf'ed
                    output to a dynamically allocated buffer while growing the
                    buffer if necessary.
                </para>
                <para>

                    It is still conceivable that the sprintf will generate a
                    long enough string that will cause a buffer overflow.
                    However, since the class is only used to render states into
                    strings, and the margin allowed for the buffer is long
                    enough, this cannot actually happen.

                </para>
            </section>
            <section xml:id="rand.c"><info><title>rand.h</title></info>

                <para>
                    Implements a random number generating class. The algorithm
                    is identical to that of the Microsoft C Run-Time Library
                    (RTL), but the generator can be instantiated.
                </para>
            </section>
            <section xml:id="fcs_hash.c"><info><title>fcs_hash.c</title></info>

                <para>
                    An optimised hash implementations. This hash maps keys to
                    values. It stores the hash function values next to the
                    keys, so two keys can be first compared with their hash
                    values, before the costly full comparison is done. It also
                    uses a secondary hash to speed up the detection of two
                    keys with identical primary hash values.
                </para>
                <para>
                    Not all the functions of the hash Abstract Data Type (ADT)
                    are implemented here. Only these that need to be used by
                    Freecell Solver.
                </para>
            </section>

            <section xml:id="fcs_dm.c"><info><title>fcs_dm.c</title></info>

                <para>

                    This module implements two functions - an advanced binary
                    search one and a function to merge a small sorted array into
                    a larger sorted array. It was used until the newer hash or
                    balanced binary tree storage were implemented, and may still
                    be used if <symbol>FCS_STATE_STORAGE_INDIRECT</symbol>
                    or <symbol>FCS_STACK_STORAGE_INDIRECT</symbol> are specified.
                    <footnote xml:id="sorted_array_as_storage">
                        <para>
                            It is no longer recommended to use a sorted array as
                            a state or stack storage, as they are much slower than
                            using a hash or a balanced binary tree, both in
                            asymptotic complexity (O(n<superscript>2</superscript>)))
                            and in average performance.
                        </para>
                    </footnote>

                </para>
            </section>

            <section xml:id="alloc.c"><info><title>alloc.c</title></info>

                <para>
                    This module compactly allocates blocks of arbitrary length,
                    usually used for dynamically allocated Freecell columns.
                    The blocks are allocated one after the other inside
                    malloc()'ed memory segments that are thus guaranteed
                    to retain their position.
                </para>
            </section>


            <section xml:id="cl_chop.c"><info><title>cl_chop.c</title></info>

                <para>
                    This module contains a class that implements a chopping of
                    a string into arguments. This is done using a subset of
                    the UNIX Bourne shell functionality. Namely:
                </para>
                <para>
                    <orderedlist inheritnum="ignore" continuation="restarts">
                        <listitem>
                            <para>
                                A backslash (\) makes the next character an
                                actual such character.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                A newline or a white-space separates a word.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                A backslash at the end of the line continues
                                the processing.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                Double quotes (") wrap an argument that may
                                contain white-space.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                A pound sign (#) makes a comment that extends
                                to the end of the line.
                            </para>
                        </listitem>
                    </orderedlist>
                </para>
                <para>
                    The code itself is very spaghetti-like but it is working.
                </para>
            </section>
            <section xml:id="pqueue.c"><info><title>pqueue.c</title></info>

                <para>
                    This module implements a priority queue as a binary heap.
                    It is derived from <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.heyes-jones.com/astar.html">Justin
                        Heyes-Jones</link> C++ code which he has kindly
                    donated to Freecell Solver (while re-licensing it under the public
                    domain). Since then, the code has been converted to ANSI C
                    , modified and optimised.
                </para>
                <para>
                    This module is used by the Best-First-Search scan.
                </para>
            </section>
        </section>
        <section xml:id="overview_of_the_core_modules"><info><title>Overview of the Core Modules</title></info>

            <para>
                Bottom-up
            </para>
            <section xml:id="card.c"><info><title>card.c</title></info>

                <para>
                    Elementary functions to convert cards to and from their
                    string representations. The <symbol>u</symbol> and
                    <symbol>p</symbol> within the code stand for "user" and
                    "perl" respectively, and mean user representation and
                    internal C representation.
                </para>
                <para>
                    The first experimental version of Freecell Solver was written in
                    Perl, and since then the naming convention for this case
                    persisted.
                </para>
            </section>

            <section xml:id="state.h"><info><title>state.h</title></info>

                <para>
                    This is a header file, but it can be considered a module
                    due to the large amount of logic that it implements. It
                    defines <type>fcs_state_t</type> (which represents a
                    complete layout of
                    the Freecell board) and of
                    <type>fcs_state_extra_info_t</type>. It contains
                    many macros for manipulating states and cards. (all of them
                    should behave like function calls)
                </para>
                <para>
                    The <type>fcs_state_extra_info_t</type> contains the real
                    positions of the stacks and freecells (refer to
                    (SECTION_REF Canonisation and Normalisation)) and other
                    things that the system uses but don't uniquely identify
                    the state in the state collection.
                </para>
            </section>

            <section xml:id="state.c"><info><title>state.c</title></info>

                <para>
                    This file contains various functions for manipulating
                    states. Among the many things implemented in it are state
                    canonisation, state duplicating, state comparison and
                    converting to and from string format.
                </para>
            </section>

            <section xml:id="move.c"><info><title>move.c and move.h</title></info>

                <para>
                    This module contains routines for handling individual moves
                    (freecell → stack, stack → freecell, stack →
                    stack) and various special moves as well as entire move
                    stacks, which contain a sequence of moves to be played
                    between two intermediate states.
                </para>
            </section>

            <section xml:id="preset.c"><info><title>preset.c</title></info>

                <para>
                    This file manages the presets: configurations of stacks
                    number, freecells number, decks number, and the other
                    parameters that define how a game is played. A preset is a
                    variant of Solitaire such as Freecell, Baker's Game, Simple
                    Simon, Good Measure, etc. Many of them are categorised in
                    PySol under different categories than the Freecell category.
                    Moreover, some "Freecell-like" games such as Penguin are
                    not supported by Freecell Solver yet.
                </para>
                <para>
                    The routines in the file enable applying a preset to an
                    instance (by its name), applying a preset to an instance
                    by a pointer to it, etc. It is also directly used by lib.c
                    to maintain consistency across a sequence of consecutive
                    instances.
                </para>
            </section>

            <section xml:id="freecell.c"><info><title>freecell.c</title></info>

                <para>

                    This module contains move functions for Freecell tests. A
                    move function receives an origin state and tries to deduce
                    if moves of a certain kind are possible. It fills in a
                    derived states list.

                </para>
                <para>
                    This code uses some macros defined in
                    <filename>meta_move_funcs_helpers.h</filename>. It contains
                    both meta-move tests and atomic moves ones.
                </para>
            </section>

            <section xml:id="simpsim.c"><info><title>simpsim.c</title></info>

                <para>
                    This file is similar in spirit to
                    <filename>freecell.c</filename> only it contains
                    <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://en.wikipedia.org/wiki/Simple_Simon_(solitaire)">Simple
                        Simon</link> move functions.
                </para>
            </section>

            <section xml:id="check_and_add_state.c"><info><title>check_and_add_state.c</title></info>

                <para>
                    This file contains the
                    <function>check_and_add_state</function>
                    function - a function that is used to determine if a
                    reached state is found in the states collection and if so,
                    to insert it there. (an operation that can be considered
                    atomic).
                </para>
                <para>
                    It has several #ifdef'ed portions used to do it for the
                    various types of states collections supported at compile
                    time. It also has a function to collect the new stacks
                    that were present in a similar fashion.
                </para>
                <para>
                    It is being used by the tests functions to put a state in
                    the state collection.
                </para>
            </section>

            <section xml:id="scans.c"><info><title>scans.c</title></info>

                <para>

                    This module contains the functions of the various scans and
                    their auxiliary functions. The scan functions run tests and
                    traverse the graph according to some inherent logic.
                    Currently present are random-dfs/soft-dfs (soft-dfs is
                    random-dfs without randomising groups),
                    Best-First-Search (named A* in the code) and
                    Breadth-First-Search (named BFS in the code) functions.

                </para>
            </section>


            <section xml:id="instance.c"><info><title>instance.c</title></info>

                <para>
                    This module contains the logic that manages a solver
                    instance, configures it and runs it. It used the scans
                    module to perform the scan and other modules to configure
                    it. Note that the interface presented here is very raw,
                    and not meant to be used as an API.
                </para>
            </section>


            <section xml:id="lib.c"><info><title>lib.c</title></info>

                <para>
                    This module contains the user API. It manages a sequence
                    of instances that can be used to solve a board, and then
                    recycled to solve another. It uses instance.c to perform
                    its operations, and do the actual configuring and solving.
                    It supplies the API header file
                    <filename>fcs_user.h</filename> which contains one
                    function for doing any given operation, and these
                    functions are implemented in lib.c.
                </para>
            </section>

            <section xml:id="cmd_line.c"><info><title>cmd_line.c</title></info>

                <para>
                    This module can be used to analyse an array of strings
                    (similar to that given to the <function>main()</function>
                    function) and configure a user instance accordingly. It
                    also implements reading such arguments from files and a
                    presets mechanism that can be used to assign names to
                    common configuration and load them.
                </para>
            </section>

        </section>

        <section xml:id="deprecated_modules"><info><title>Deprecated Modules</title></info>



            <para>

                These are modules that were previously used but have been
                superseded by different code. They can still be found in
                the <filename>fc-solve/rejects</filename> directory
                of the trunk.

            </para>

            <section xml:id="lookup2.c"><info><title>lookup2.c</title></info>

                <para>

                    This module implements a
                    <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://burtleburtle.net/bob/hash/">hash
                        function</link>
                    that was developed by <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://burtleburtle.net/bob/">Bob Jenkins</link>.
                    It is essentially his code, that was just integrated into
                    Freecell Solver for convenience (note that it is also Public Domain).

                </para>
            </section>


            <section xml:id="fcs_isa.c"><info><title>fcs_isa.c</title></info>

                <para>

                    This module implemented indirect state allocation for
                    states. It allocates states in memory pools (called packs)
                    which have a fixed location in memory and allocates as
                    many such pools as it can.

                </para>

                <para>

                    Each pool contains several states that are placed one after
                    the other, that thus retain their pointer. That way, memory
                    is conserved as an individually malloced state may have a
                    lot of overhead. (a malloced block+a fixed amount of data
                    is rounded to the nearest power of 2)

                </para>
                <para>
                    fcs_isa allows releasing the last allocated state in case
                    it will not be used.
                </para>
            </section>

        </section>
    </chapter>
    <chapter xml:id="techniques"><info><title>Interesting Techniques Used throughout the Code</title></info>

        <section xml:id="technique_state_representation"><info><title>State Representation</title></info>

            <para>
                As can be seen in <filename>state.h</filename>, Freecell Solver
                supports two ways to represent a state:
            </para>
            <para>
                <orderedlist inheritnum="ignore" continuation="restarts">
                    <listitem>
                        <para>
                            <emphasis>Compact States</emphasis> - in this
                            configuration the data is one buffer of chars,
                            where each card and each stack counter are
                            represented as one character, and each freecell and
                            foundation is one char too.
                        </para>
                        <para>
                            Determining the locations of every card is done
                            using offset calculation.
                        </para>
                        <para>
                            This configuration consumes much less memory than
                            Debug States, but it doesn't scale well to games
                            where the stacks can contain a lot of cards.
                            The reason is that every stack be of a fixed size
                            (so offset would be determined by means of
                            multiplication).
                        </para>
                        <para>
                            This configuration used to be the fastest for
                            limited stack games such as Freecell. After
                            Freecell Solver 2.6.x, it seems that Indirect Stack States
                            has become slightly faster than it.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <emphasis>Indirect Stack States</emphasis> -
                            in this configuration
                            each stack is a pointer to a stack in memory.
                            The stacks are also collected and there is one copy
                            of each stack organisation (say [KS QH 6H]) in
                            memory. Since a pointer to a stack uniquely
                            identifies a stack, the states can be compared by
                            comparing their memory contents.
                        </para>
                        <para>

                            This is now the default configuration, and in the
                            2.5.x development tree, many enhancements were done
                            to optimise it. It was benchmarked to be slightly
                            faster than Compact States, even for games like
                            Freecell.

                        </para>
                    </listitem>
                </orderedlist>
            </para>
        </section>

        <section xml:id="technique_indirect_stack_states_algorithms"><info><title>Indirect Stack States Algorithms</title></info>

            <para>
                The stacks are kept in their own stack collection in the
                freecell_solver_instance struct. When a move function wishes to
                create a derived states, it first copies the state, and then
                marks the flags of all the stacks as cleared. (check
                <symbol>(*Mark STACKS_COW_CLEAR *)</symbol> in the code).
            </para>
            <para>
                Later on when a stack is changed, its flag is set, and a
                stack is copied to a indirect stacks buffer of the
                hard thread.
                and modified there. (check (*Mark STACKS_COW_COPY_STACK*) ).
            </para>
            <para>
                The check_and_add_state function then, when checking a
                new state, ignores those stacks whose flag was not set,
                and collects the stacks whose flag was set.
                ( <symbol>(*Mark STACKS_COW_CACHING*)</symbol> ). The
                memory for the collected stacks is allocated compactly in
                a segment, where one stack starts after the other
                (check <filename>alloc.c</filename> and <filename>alloc.h</filename>).
                If the stack was found in the collection the memory that was
                allocated is freed for use by future stacks).
            </para>
        </section>

        <section xml:id="technique_extended_states"><info><title>Extended States</title></info>

            <para>

                For each position in the game graph, Freecell Solver maintains
                a data structure which identifies it called
                <type>fcs_state_t</type>. This contains the cards in the stacks
                and the freecells, and the value of the foundations. The stacks
                and freecells are uniquely sorted to avoid states that are
                identical except for a different permutation of the stacks
                or the freecells.

            </para>
            <para>
                <type>fcs_state_extra_info_t</type> contains a pointer to the
                <type>fcs_state_t</type> which it is associated with,
                and defines some other data. The real locations of the stacks
                and freecells are stored there for instance, as well as some
                graph information. See
                <link linkend="term_canonisation">Canonisation</link> and
                <link linkend="term_normalisation">Normalisation</link> in the
                <link linkend="terms">terminology</link>.
            </para>
        </section>
        <section xml:id="technique_the_states_graph_and_its_use"><info><title>The States Graph and its Use</title></info>

            <para>
                When a brand new state is discovered its parent is assigned to
                be the state from which it is derived. (check <symbol>(*Mark
                    STATE_PARENT*)</symbol>). Its depth is assigned to be the
                depth of the parent + 1. There is a command line option
                (--reparent-states) that specifies that if an existing state
                whose depth is higher than the depth of state it was derived
                from + 1 is reached, then its parent would be re-assigned.
            </para>
            <para>
                An extended state has a num_active_children counter that
                specifies how many of those states that consider it their
                parent were still not marked as dead ends. If this counter
                reaches 0, this state also becomes inactive.
            </para>

            <para>
                The state has a vector of flags called scan_visited, that
                specifies if a given scan has visited it yet. If it is a
                complete scan it can also mark it as dead end should it:
            </para>

            <para>
                <orderedlist inheritnum="ignore" continuation="restarts">
                    <listitem>
                        <para>
                            Recurse out of it if it's a DFS scan.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Find that it has no derived states if it is a
                            Best-First Search scan.
                        </para>
                    </listitem>
                </orderedlist>
            </para>
            <para>
                If it is marked as dead end, then its parent's counter would be
                incremented. If the latter is zero, the process may continue to
                the grand parent and so forth.
            </para>
        </section>

        <section xml:id="technique_life_cycle_of_a_f_s_instance_t"><info><title>The Life-Cycle of a freecell_solver_instance_t</title></info>

            <para>
                A <type>freecell_solver_instance_t</type> is allocated by
                <filename>lib.c</filename> to start solving a board. The logic
                of solving a board is present in <filename>intrface.c</filename>
                while the external API functions to use it are implemented in
                <filename>lib.c</filename>.
            </para>
            <para>
                After an instance is allocated, it should be parametrised to
                specify how it will solve the board. Afterwards,
                <function>freecell_solver_init_instance()</function> should
                be called. After that,
                <function>freecell_solver_solve_instance()</function> should
                be called for the first time, and
                <function>freecell_solver_resume_instance()</function> afterwards.
                (these functions solve until they reach a limit of iterations
                number.)
            </para>
            <para>
                If one would like to use the instance to solve another board,
                it is possible to recycle it by calling
                <function>freecell_solver_recycle_instance()</function>.  This will
                keep its configuration but free all its associated resources, and
                thus will not require parsing the command line again.
            </para>
            <para>
                The function that calls the actual scans is
                <function>run_hard_thread()</function>, which is called from
                within <function>freecell_solver_resume_instance()</function>.
            </para>
        </section>

        <section xml:id="technique_compact_allocation"><info><title>Compact Allocation</title></info>

            <para>

                Most resources that are allocated arbitrarily in Freecell Solver are
                allocated in a compact manner. I.e: instead of being
                individually malloced, they are allocated in segments and
                placed one after the other. The segments are dynamically
                allocated and kept at a fixed location in memory. If more
                memory is needed, another segment is allocated.

            </para>
            <para>
                 The module that is responsible for this is:
            </para>
            <para>
                <orderedlist inheritnum="ignore" continuation="restarts">
                    <listitem>
                        <para>
                            <filename>alloc.c</filename>/<filename>alloc.h</filename> -
                            allocates blocks of arbitrary size in a compact manner.
                        </para>
                    </listitem>
                </orderedlist>
            </para>

            <para>
                It supports releasing the last allocated block
                and the last one alone.
            </para>
            <para>
                Compact allocation is used for the following resources.
            </para>
            <para>
                <orderedlist inheritnum="ignore" continuation="restarts">
                    <listitem>
                        <para>

                            <emphasis>States</emphasis> - a derived state is
                            allocated using the hard thread's allocator, and it
                            is modified with the appropriate moves. If it is
                            found to have already existed, it is released.
                            Else, it is kept and a pointer to it can be found
                            in the states collection.

                        </para>
                    </listitem>
                    <listitem>
                        <para>

                            <emphasis>Card stacks</emphasis> - if a card stack
                            was modified, it is compactly allocated (see
                            <symbol>(*Mark COMPACT_ALLOC_CARD_STACKS*)</symbol>
                            ), before one checks to see if it is present in the
                            stacks collection. If it was found there, its
                            memory is released. Else, it is kept there.

                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <emphasis>Move stacks</emphasis> -
                            the move stacks leading to the parent are compactly
                            allocated (see (*Mark COMPACT_ALLOC_MOVE_STACKS*)).
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <emphasis>Hash Elements</emphasis> - The elements
                            of the hash linked lists are compactly allocated
                            with a hash-wide hash allocator.
                        </para>
                    </listitem>
                </orderedlist>
            </para>
        </section>
    </chapter>
    <chapter xml:id="scm"><info><title>Software Configuration Management</title></info>

        <section xml:id="scm_game_presets_configuration"><info><title>Game Presets Configuration</title></info>

            <para>
                The info for generating the game presets is present in the
                file <filename>gen_presets.pl</filename>. It
                uses <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://groups.yahoo.com/group/fc-solve-discuss/message/51">data
                    structure inheritance</link> to determine the exact
                parameters to be included in each preset. Its output should
                later be incorporated into <filename>presets.c</filename>.
            </para>
        </section>

        <section xml:id="scm_generating_the_site"><info><title>Generating the Site</title></info>

            <para>
                The site lies in the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://github.com/shlomif/fc-solve/tree/master/fc-solve/site/wml">sub-directory of
                    fc-solve/site/wml in the VCS repository's trunk</link> and
                is generated using GNU Make, and
                <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://thewml.org/">Website
                    Meta Language</link> .
            </para>

            <para>
                The <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://fc-solve.shlomifish.org/">main site </link>
                is generated from a makefile and uploaded to
                its place using rsync.
            </para>

        </section>

        <section xml:id="scm_pkg_config"><info><title>The pkg-config File</title></info>

            <para>
                The CMake process generates a
                <filename>libfreecell-solver.pc</filename> file that
                can be used as an aid in programs wishing to compile and link
                against Freecell Solver. It is generated from
                <filename>libfreecell-solver.pc.in </filename> by
                CMake and installed system-wide.
            </para>
        </section>

        <section xml:id="scm_win32_binary"><info><title>The Win32 Binary</title></info>


            <para>

                The Windows 32-bit binary can be generated by running CMake
                on Windows on the Freecell Solver distribution, generating a
                MinGW makefile and type "make package". There's a script
                to automate it:
                <filename>scripts/build-on-win32.pl</filename> .

            </para>

        </section>

    </chapter>
    <chapter xml:id="terms"><info><title>Terminology</title></info>

        <section xml:id="terms_terms"><info><title>Terms used throughout the Code</title></info>

            <variablelist><info><title>Terms used throughout the Code</title></info>

                <varlistentry>
                    <term xml:id="term_canonisation">Canonisation</term>
                    <listitem>
                        <para>
                            An extended state is canonised by its stacks being
                            uniquely sorted according to their contents, and an
                            array of indexes describing their original locations
                            sorted accordingly. This is done to make sure no two
                            states with the same permutation of states exist.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Depth</term>
                    <listitem>
                        <orderedlist inheritnum="ignore" continuation="restarts">
                            <listitem>
                                <para>
                                    The number of successive state
                                    → state.parent operations it take to
                                    reach the initial state which is the base
                                    of the states graph.
                                </para>
                            </listitem>
                            <listitem>
                                <para>
                                    In Depth-First-Search (DFS): the position of
                                    the state in the recursion stack.
                                </para>
                            </listitem>
                        </orderedlist>
                    </listitem>
                </varlistentry>
                <varlistentry xml:id="term_false_impossible">
                    <term>False Impossible</term>
                    <listitem>
                        <para>
                            A false impossible is an initial board position
                            for which the solver reports as impossible to
                            solve, yet can be solved in some way. A false
                            impossible may be considered a bug depending on
                            the context.
                        </para>
                        <para>
                            A meta-moves-based scan can potentially have false
                            impossibles, while an atomic moves one (which does
                            not prune in any way) cannot.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>False Negative</term>
                    <listitem>
                        <para>
                            See <link linked="term_false_impossible">False
                                Impossible</link>.
                        </para>
                    </listitem>
                </varlistentry>


                <varlistentry>
                    <term>f_s_</term>
                    <listitem>
                        <para>
                            Short for "fc_solve_" or "freecell_solver_".
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>freecell_solver_user</term>
                    <listitem>
                        <para>
                            a generic name of the API used by the programmer
                            who wishes to utilise the Freecell Solver library in his
                            application. Named after the prefix of the functions
                            of this library.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Graph</term>
                    <listitem>
                        <para>
                            The states in the state collection form a directed
                            graph. Each link is a state → derived state
                            relationship.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Hard DFS</term>
                    <listitem>
                        <para>
                            A Depth-First Search scan that uses procedural
                            recursion. Since suspending a scan and resuming
                            it are O(d) operations (where d is the depth)
                            instead of O(1) for Soft-DFS its use is
                            deprecated. As a result of this, Hard-DFS was
                            removed from the code, and when being specified,
                            it is implemented by Soft-DFS.
                        </para>

                        <para>
                            Hard-DFS was the original scan supported by
                            Freecell Solver 0.2.0.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Hard Thread</term>
                    <listitem>
                        <para>
                            A collection of soft threads, that should
                            generally be placed in one system thread. Hard
                            thread contains resources that soft threads from
                            different hard threads would interfere with each
                            other in allocating. Hard threads contain a
                            collection of state packs, and various counters
                            and other variables.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Instance</term>
                    <listitem>
                        <para>

                            An initial board, a collection of states and all
                            the scans associated with it. An instance is
                            initialised whenever one wishes to solve new board.
                            By using command line parameters it is possible to
                            configure it to solve the board in many ways.
                            Instance logic is implemented in
                            <filename>intrface.c</filename>, and the user API
                            is implemented in <filename>lib.c</filename>. Users
                            are advised to make use of the command line
                            interface in <filename>cmd_line.c</filename>.

                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Intractable</term>
                    <listitem>
                        <para>

                            An initial layout of the board that cause the
                            solver to terminate the scan prematurely (due to
                            limitations on the iterations and the such) without
                            determining whether the board was solvable or not.

                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Iterations</term>
                    <listitem>
                        <para>

                            the number of states checked by a scan, or by all
                            the scans of a hard thread or of an instance. An
                            iterations limit (called num_times in the code) is
                            used to restrict a soft thread, hard thread or
                            instance from running too long, and to allocate
                            time quotas for different soft threads.

                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Meta-Move</term>
                    <listitem>
                        <para>

                            A move that consists of several individual moves
                            done as one, to move from state to a derived state.
                            Some of the Freecell tests and all of the
                            Simple Simon tests generate meta-moves.

                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Move</term>
                    <listitem>
                        <para>

                            A one-time displacements of cards from stacks to
                            stacks, from stacks to freecells, or from freecells
                            to stacks. Also contain some special moves such as
                            those for canonising stacks, and separators. Also
                            see Move Stacks.

                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry xml:id="term_move_stacks">
                    <term>Move Stacks</term>
                    <listitem>
                        <para>

                            A sequence of moves implemented in its own object
                            (check <filename>move.c</filename> and
                            <filename>move.h</filename>).

                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term xml:id="term_normalisation">Normalisation</term>
                    <listitem>
                        <para>

                            normalisation is the opposite of canonisation. It
                            is meant to bring the stacks and freecells to their
                            absolute locations. It is normally done only when
                            presenting a state to the user or to a code that
                            uses the API.

                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Parent</term>
                    <listitem>
                        <para>

                            The state from which one state in the state graph
                            was initially derived from. It is possible that
                            this state would eventually be reached from a
                            different state, but its parent in that case,
                            remains the same.

                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Presets</term>
                    <listitem>
                        <para>
                            <orderedlist inheritnum="ignore" continuation="restarts">
                                <listitem>
                                    <para>

                                        A structure specifying the type of game
                                        according to number of stacks, number
                                        of freecells, number of decks, whether
                                        kings can be placed in empty stacks, if
                                        sequences have unlimited moves, and how
                                        stacks are built by. Defined in
                                        <filename>preset.c</filename>.

                                    </para>
                                </listitem>
                                <listitem>
                                    <para>

                                        A set of command line arguments to be
                                        processed as if they were given on the
                                        command line. Can be used to shorten
                                        command lines. For instance "-l
                                        cool-jives" or "-l john-galt-line" load
                                        the presets "cool-jives" and
                                        "john-galt-line" respectively.
                                        Implemented mostly in
                                        <filename>cmd_line.c</filename>.

                                    </para>
                                </listitem>
                            </orderedlist>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Re-parent</term>
                    <listitem>
                        <para>

                            Let's suppose state DEST has been derived from
                            state SRC. If the SRC.depth+1 is less than
                            DEST.depth than DEST's parent will be reassigned
                            to SRC. (if reparenting is enabled)

                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry xml:id="term_soft_dfs">
                    <term>Soft DFS</term>
                    <listitem>
                        <para>

                            A depth-first search scan that does not utilise
                            procedural recursion. In Freecell Solver, this utilises a
                            stack of records, each containing the current
                            state, the current test, the list of derived
                            states, and other information. This deviates from
                            the standard scheme that puts every state at the
                            end of one stack scheme (that exists in <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.shlomifish.org/lm-solve/">LM-Solve</link>
                            for example) and is harder to maintain, but can be
                            fine-tuned and conserve resources more easily.

                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Soft Thread</term>
                    <listitem>
                        <para>

                            A singular continuous scan operating on a states
                            collection. It can be Soft-DFS, Hard-DFS or Best
                            First Search. There could be any number of soft
                            threads in a hard thread.

                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Stacks</term>
                    <listitem>
                        <para>
                            <orderedlist inheritnum="ignore" continuation="restarts">
                                <listitem>
                                    <para>
                                        <link linkend="term_move_stacks">Move
                                            Stacks</link> (refer to them)
                                    </para>
                                </listitem>
                                <listitem>
                                    <para>
                                        Columns of the Freecell-like games.
                                    </para>
                                </listitem>
                                <listitem>
                                    <para>
                                        The stack used for maintaining the
                                        <link linkend="term_soft_dfs">Soft-DFS</link>
                                        recursion.
                                    </para>
                                </listitem>
                                <listitem>
                                    <para>
                                        The environment recursion stack.
                                    </para>
                                </listitem>
                            </orderedlist>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>State</term>
                    <listitem>
                        <para>

                            The position of the game at any given situation. A
                            state accurately describes the contents of the
                            stacks, freecells, and foundations at any given
                            time. A human seeing a state can solve the game
                            from it without further information.

                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>State Collection</term>
                    <listitem>
                        <para>

                            A collection that collects every state once and
                            only
                            once.  It can be sought of as an associative
                            array (or a map) of keys (the
                            <type>fcs_state_t</type>)
                            to values (<type>fcs_state_extra_info_t</type>)
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Test Groups</term>
                    <listitem>
                        <para>
                            A grouping of tests/move funcs that dictate which
                            one should be performed one after the and placed
                            into the same derived states list. Afterwards, this
                            list can be randomised, or prioritised.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Tests</term>
                    <listitem>
                        <para>
                            A function that accepts a source state as input
                            and fills a list of derived states according to
                            the moves it can perform. Each game type has
                            several type of tests, which can be ordered and
                            grouped according to input from the user. Now the
                            term "move function/func" is preferred.
                        </para>
                    </listitem>
                </varlistentry>

                <!--
                I keep the following code around to be used as a template for
                new entries:

                <varlistentry>
                    <term></term>
                    <listitem>
                        <para>
                        </para>
                    </listitem>
                </varlistentry>
                -->

            </variablelist>
        </section>
    </chapter>
</book>
