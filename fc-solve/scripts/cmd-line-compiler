#!/usr/bin/perl

use strict;
use warnings;

BEGIN
{
    if ( !@ARGV or $ARGV[0] ne 'compile' )
    {
        print <<'EOF'
To run do:
export FCS_PATH="`pwd`" FCS_SRC_PATH="`pwd`/../source"
perl ../scripts/cmd-line-compiler compile
EOF
    }
}

use Socket qw(:crlf);
use Path::Tiny qw/ path /;
use lib "$ENV{FCS_SRC_PATH}/t/lib";
use FC_Solve::CmdLine::Expand ();

sub _normalize_lf
{
    my ($s) = @_;
    $s =~ s#$CRLF#$LF#g;
    return $s;
}

sub _normalize_lf_list
{
    return [ map { _normalize_lf($_) } @{ shift @_ } ];
}

sub compile_cmd_line
{
    my $args       = shift;
    my $input_argv = $args->{argv};

    my $obj = FC_Solve::CmdLine::Expand->new(
        {
            input_argv => $input_argv,
        }
    );

    my $expanded = _normalize_lf_list( $obj->argv() );
    my $out      = <<'EOF';
#pragma once
#define freecell_solver_user_set_soft_thread_name(st, n)
extern void fc_solve_user_set_ht_compiled_prelude(void *, size_t, const fc_solve_prelude_item *);
static inline void my_init_instance(void *const instance)
{
EOF

    my %names;
    my $soft_thread_idx = 0;
    my %one_param = (
        '-dto' => {
            f => 'freecell_solver_user_set_depth_tests_order',
            p => sub {
                my $p = shift;
                my ( $complete, $d, $to ) = $p =~ /\A(([0-9]+),(.*))\z/ms;
                return qq#$d, "$complete" FCS__PASS_ERR_STR(&fcs_user_errstr)#;
            },
        },
        '-dto2' => {
            f => 'freecell_solver_user_set_depth_tests_order',
            p => sub {
                my $p = shift;
                my ( $complete, $d, $to ) = $p =~ /\A(([0-9]+),(.*))\z/ms;
                return qq#$d, "$to" FCS__PASS_ERR_STR(&fcs_user_errstr)#;
            },
        },
        '--method' => {
            f => 'freecell_solver_user_set_solving_method',
            p => sub {
                return {
                    'random-dfs' => 'FCS_METHOD_RANDOM_DFS',
                    'a-star'     => 'FCS_METHOD_A_STAR',
                }->{ shift(@_) };
            },
        },
        '-seed' => {
            f => 'freecell_solver_user_set_random_seed',
            p => sub { return shift; },
        },
        '-sp' => {
            f => 'freecell_solver_user_set_pruning',
            p => sub {
                return qq#"# . shift
                    . qq#" FCS__PASS_ERR_STR(&fcs_user_errstr)#;
            },
        },
        '-step' => {
            f => 'freecell_solver_user_set_soft_thread_step',
            p => sub { return shift; },
        },
        '--st-name' => {
            f => 'freecell_solver_user_set_soft_thread_name',
            p => sub { my $name = shift; $names{$name} = $soft_thread_idx; return qq#"$name"#; },
        },
        '-to' => {
            f => 'freecell_solver_user_set_depth_tests_order',
            p => sub {
                return qq#0, "# . shift
                    . qq#" FCS__PASS_ERR_STR(&fcs_user_errstr)#;
            },
        },
    );

    for ( my $i = 0 ; $i < @$expanded ; ++$i )
    {
        my $s = $expanded->[$i];
        if ( my $rec = $one_param{$s} )
        {
            my $param = $expanded->[ ++$i ];
            $out .= "$rec->{f}(instance," . $rec->{p}->($param) . ");\n";
        }
        elsif ( $s eq '--prelude') {
            my $param = $expanded->[ ++$i ];
            my $f = 'fc_solve_user_set_ht_compiled_prelude';
            my @pre = map { [ split/\@/, $_]} split /,/, $param;
            $out .= <<"EOF"
{
    static const fc_solve_prelude_item prelude[@{[scalar @pre]}] = {@{[join ",", map { "{.quota = $_->[0], .scan_idx = " . $names{$_->[1]} . '}' } @pre]}};
    $f(instance, @{[scalar @pre]}, prelude);
}
EOF
        }
        elsif ( $s eq '-nst' )
        {
            ++$soft_thread_idx;
            $out .= qq#freecell_solver_user_next_soft_thread(instance);\n#;
        }
        elsif ( $s eq '-asw' )
        {
            my $param = $expanded->[ ++$i ];
            my @vals = split /,/, $param;
            while ( my ( $pos, $v ) = each @vals )
            {
                $out .=
qq#freecell_solver_user_set_a_star_weight(instance, $pos, $v);\n#;
            }
        }
        else
        {
            die "Unrecognised command line argument <$s>!";
        }
    }

    $out .= "}\n";
    path( $args->{out_fn} )->spew_utf8($out);

    return;
}

# TEST
compile_cmd_line(
    {
        # argv   => [ '-l', 'obf', ],
        argv => [
            '--read-from-file',
            "4,$ENV{FCS_SRC_PATH}/../scripts/TEST_OPTIMIZATIONS/cm-mod1.sh",
        ],
        name   => 'obf',
        out_fn => 'fc_solve__precompiled__theme.h',
    },
);

__END__

=head1 COPYRIGHT AND LICENSE

This file is part of Freecell Solver. It is subject to the license terms in
the COPYING.txt file found in the top-level directory of this distribution
and at http://fc-solve.shlomifish.org/docs/distro/COPYING.html . No part of
Freecell Solver, including this file, may be copied, modified, propagated,
or distributed except according to the terms contained in the COPYING file.

Copyright (c) 2009 Shlomi Fish

=cut
